## Part4

- Build tools. Our project will be mainly developed in C++, so we'll use **cmake** or **bazel**
as our main method to build and organize our project. For the specific compilers and tool chains
to actually compile the program, we'll be using **GNU make** and **G++** or **clang** for Linux users,
and probably **VC++** for Windows users.

- Style checker. To ensure the style of our code is consistent and graceful, we'll use automatic
style checking tool **clang-format** to maintain the style of our code. We'll first discuss the
code style checking rules in advance and write a `.clang-format` file to be put in the main directory
of our project. Each new code patch will be checked by **clang-format** against the `.clang-format`
file before it can be committed.

- Static bug finder. **clangd** will be our main tool for static bug analysis. It works well together with
vscode or CLion, so our teamates with different developing platforms could all use that.

- Test runner. Our main test runner will be **Google Test**. For each class, we'll have a `test_xxx.cpp`
file to conduct the corresponding unit tests, and we'll `TEST_T` for each public or private function for
the classes.

- Mocking framework. **GMock Framework** will be our tool for mocking the objects in testing.

- Coverage tracker. We might use **opencppcoverage** or **Clang Source-based Code Coverage** to measure
the coverage of the tested code.

- Other frameworks. **C++ REST SDK** or **Google RPC** might be used for implementing our HTTP RESTful APIs. **Google Proto Buffers** or **Thrift** might be used for formatting and transferring
the messages between some of our backend micro-services. **SQLAPI++** or other database clients might be used
to connect our backend services with databases, depending on the type of databases we use. **nlohmann json**
or **RapidJSON** could be used to handle some json-formatted data. **cpp-jwt** might be used for encode and decode
the tokens and cookies of our users. 